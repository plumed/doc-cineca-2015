<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>PLUMED: Munster tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table align="center" frame="void" width="98%" cellpadding="2%">
<tbody>
<tr style="height: 30px;">
<td valign="center"> &nbsp; <img src="pigeon.png" width="120"/></td>
<td style="padding-left: 0.2em;" width="74%"> <a href="http://www.plumed-code.org"> <img src="logo.png" width="400" /> </td>
<td style="padding-left: 0.2em;" align="right"> <a href="../../developer-doc/html/index.html"> <img src="user-logo.png" width="180" /> </a> </td>
</tr>
</tbody>
</table>
<!--
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PLUMED
   &#160;<span id="projectnumber">2.3.0-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
-->
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Home&#160;(cineca-2015)</span></a></li>
      <li><a href="_syntax.html"><span>Getting&#160;started</span></a></li>
      <li><a href="tutorials.html"><span>Tutorials</span></a></li>
      <li><a href="glossary.html"><span>Index&#160;of&#160;Actions</span></a></li>
      <li><a href="cineca.html"><span>Cineca</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('munster.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Munster tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Authors</dt><dd>Max Bonomi and Giovanni Bussi, stealing a lot of material from other tutorials. Richard Cunha is acknowledged for beta-testing this tutorial. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>March 11, 2015</dd></dl>
<p>This document describes the PLUMED tutorial held in Munster, March 2015. The aim of this tutorial is to learn how to use PLUMED to analyze molecular dynamics simulations on the fly, to analyze existing trajectories, and to perform enhanced sampling. Although the presented input files are correct, the users are invited to <b>refer to the literature to understand how the parameters of enhanced sampling methods should be chosen in a real application.</b></p>
<p>Users are also encouraged to follow the links to the full PLUMED reference documentation and to wander around in the manual to discover the many available features and to do the other, more complete, tutorials. Here we are going to present only a very narrow selection of methods.</p>
<p>We here use PLUMED 2.1 syntax and we explicitly note if some syntax is expected to change in PLUMED 2.2, which will be released later in 2015. All the tests here are performed on a toy system, alanine dipeptide, simulated using the AMBER99SB force field. We provide both a setup that includes explicit water, which is more realistic but slower, and a setup in gas phase, which is much faster. Simulations are made using GROMACS 4.6.7, which is here assumed to be already patched with PLUMED and properly installed. However, these examples could be easily converted to other MD software.</p>
<p>All the gromacs input files and analsys scripts are provided in this <a href="tutorial-resources/munster.tar.gz" download="munster.tar.gz">tarball </a>.</p>
<p>Users are expected to write PLUMED input files based on the instructions below.</p>
<h1><a class="anchor" id="munster-toymodel"></a>
Alanine dipeptide: our toy model</h1>
<p>In this tutorial we will play with alanine dipeptide (see Fig. <a class="el" href="munster.html#munster-1-ala-fig">munster-1-ala-fig</a>). This rather simple molecule is useful to make benchmark that are around for data analysis and free energy methods. It is a nice example since it presents two metastable states separated by a high (free) energy barrier. Here metastable states are intended as states which have a relatively low free energy compared to adjacent conformations. It is conventional use to show the two states in terms of Ramachandran dihedral angles, which are denoted with \( \Phi \) and \( \Psi \) in Fig. <a class="el" href="munster.html#munster-1-transition-fig">munster-1-transition-fig</a> .</p>
<p><a class="anchor" id="munster-1-ala-fig"></a></p><div class="image">
<img src="belfast-2-ala.png" alt="belfast-2-ala.png"/>
<div class="caption">
The molecule of the day: alanine dipeptide.</div></div>
<p> <a class="anchor" id="munster-1-transition-fig"></a></p><div class="image">
<img src="belfast-2-transition.png" alt="belfast-2-transition.png"/>
<div class="caption">
Two metastable states of alanine dipeptide are characterized by their Ramachandran dihedral angles.</div></div>
 <h1><a class="anchor" id="munster-monitor"></a>
Monitoring collective variables</h1>
<p>The main goal of PLUMED is to compute collective variables, which are complex descriptors than can be used to analyze a conformational change or a chemical reaction. This can be done either on the fly, that is during molecular dynamics, or a posteriori, using PLUMED as a post-processing tool. In both cases one should create an input file with a specific PLUMED syntax. A sample input file is below:</p>
<pre class="fragment"># compute distance between atoms 1 and 10
d: DISTANCE ATOMS=1,10
# create a virtual atom in the center between atoms 20 and 30
center: CENTER ATOMS=20,30
# compute torsional angle between atoms 1,10,20 and center
phi: TORSION ATOMS=1,10,20,center
# compute some function of previously computed variables
d2: MATHEVAL ARG=phi FUNC=cos(x) PERIODIC=NO
# print both of them every 10 step
PRINT ARG=d,phi,d2 STRIDE=10
</pre><p> (see <a class="el" href="_d_i_s_t_a_n_c_e.html">DISTANCE</a>, <a class="el" href="_c_e_n_t_e_r.html">CENTER</a>, <a class="el" href="_t_o_r_s_i_o_n.html">TORSION</a>, <a class="el" href="_m_a_t_h_e_v_a_l.html">MATHEVAL</a>, and <a class="el" href="_p_r_i_n_t.html">PRINT</a>)</p>
<p>PLUMED works using kJ/nm/ps as energy/length/time units. This can be personalized using <a class="el" href="_u_n_i_t_s.html">UNITS</a>. Notice that variables should be given a name (in the example above, <code>d</code>, <code>phi</code>, and <code>d2</code>), which is then used to refer to these variables. Lists of atoms should be provided as comma separated numbers, with no space. Virtual atoms can be created and assigned a name for later use. You can find more information on the PLUMED syntax at <a class="el" href="_syntax.html">Getting started</a> page of the manual. The complete documentation for all the supported collective variables can be found at the <a class="el" href="colvarintro.html">Collective variables</a> page.</p>
<h2><a class="anchor" id="munster-monitor-of"></a>
Analyze on the fly</h2>
<p>Here we will run a plain MD on alanine dipeptide and compute two torsional angles on the fly. GROMACS needs a .tpr file, which is a binary file containing initial positions as well as force-field parameters. We also provide .gro, .mdp, and .top files, that can be modified and used to generate a new .tpr file. For this tutorial, it is sufficient to use the provided .tpr files. You will find several tpr files, namely:</p><ul>
<li>topolAwat.tpr - setup in water, initialized in state A</li>
<li>topolBwat.tpr - setup in water, initialized in state B</li>
<li>topolA.tpr - setup in vacuum, initialized in state A</li>
<li>topolB.tpr - setup in vacuum, initialized in state B</li>
</ul>
<p>Gromacs md can be run using on the command line: </p><pre class="fragment">&gt; mdrun_mpi -s topolA.tpr -nsteps 10000
</pre><p> The nsteps flags can be used to change the number of timesteps and topolA.tpr is the name of the tpr file. While running, gromacs will produce an md.log file, with log information, and a traj.xtc file, with a binary trajectory. The trajectory can be visualized with VMD using a command such as </p><pre class="fragment">&gt; vmd confout.gro tra.xtc
</pre><p>To run a simulation with gromacs+plumed you just need to add a -plumed flag </p><pre class="fragment">&gt; mdrun_mpi -s topolA.tpr -nsteps 10000 -plumed plumed.dat
</pre><p> Here plumed.dat is the name of the plumed input file. Notice that PLUMED will write information in the md.log that could be useful to verify if the simulation has been set up properly.</p>
<h3><a class="anchor" id="munster-exercise-0"></a>
Exercise 0</h3>
<p>In this exercise, we will run a plain molecular dynamics simulation and monitor the \(\Phi\) and \(\Psi\) dihedral angles on the fly. Using the following PLUMED input file you can monitor \(\Phi\) and \(\Psi\) angles during the MD simulation </p><pre class="fragment">phi: TORSION ATOMS=5,7,9,15
psi: TORSION ATOMS=7,9,15,17
PRINT ARG=phi,psi STRIDE=100 FILE=colvar
</pre><p> (see <a class="el" href="_t_o_r_s_i_o_n.html">TORSION</a> and <a class="el" href="_p_r_i_n_t.html">PRINT</a>)</p>
<p>Notice that PLUMED is going to compute the collective variables only when necessary, that is, in this case, every 100 steps. This is not very relevant for simple variables such as torsional angles, but provides a significant speedup when using expensive collective variables.</p>
<p>PLUMED will write a textual file named <code>colvar</code> containing three columns: physical time, \(\Phi\) and \(\Psi\). Results can be plotted using gnuplot: </p><pre class="fragment">&gt; gnuplot
# this shows phi as a function of time
gnuplot&gt; plot "colvar" u 2
# this shows psi as a function of time
gnuplot&gt; plot "colvar" u 3
# this shows psi as a function of phi
gnuplot&gt; plot "colvar" u 2:3
</pre><p>Now try to do the same using the two different initial configurations that we provided (<code>topolA.tpr</code> and <code>topolB.tpr</code>). You can try both setup (water and vacuum). Results from 200ps (100000 steps) trajectories in vacuum are shown in Figure <a class="el" href="munster.html#munster-ala-traj">munster-ala-traj</a>.</p>
<p><a class="anchor" id="munster-ala-traj"></a></p><div class="image">
<img src="munster-ala-traj.png" alt="munster-ala-traj.png"/>
<div class="caption">
(phi,psi) scatter plot obtained starting from two different structures. Simulation performed in vacuum.</div></div>
<p> Notice that the result depends heavily on the starting structure. For the simulation in vacuum, the two free-energy minima are separated by a large barrier and, in such a short simulation, the system cannot cross it. In water the barrier is smaller and you might see some crossing. Also notice that the two clouds are well separated, indicating that these two collective variables are good enough to properly distinguish among the two minima.</p>
<p>As a final comment, notice that if you run twice the same calculation in the same directory, you might overwrite the resulting files. GROMACS takes automatic backup of the output files, and PLUMED does it as well. In case you are restarting a simulation, you can add the keyword <a class="el" href="_r_e_s_t_a_r_t.html">RESTART</a> at the beginning of the PLUMED input file. This will tell PLUMED to <em>append</em> files instead of taking a backup copy.</p>
<p> <details> <summary> <b> To learn more: Analyze using the driver </b> </summary> <div class="hidden">  </p>
<h2><a class="anchor" id="munster-monitor-dr"></a>
Analyze using the driver</h2>
<p>Imagine you already made a simulation, with or without PLUMED. You might want to compute the collective variables a posteriori, from the trajectory file. You can do this by using the plumed executable on the command line. Type </p><pre class="fragment">&gt; plumed driver --help
</pre><p> to have an idea of the possible options. See <a class="el" href="driver.html">driver</a> for the full documentation.</p>
<p>Here we will use the driver the compute \(\Phi\) and \(\Psi\) on the already generated trajectory. Let's assume the trajectory is named <code>traj.xtc</code>. You should prepare an PLUMED input file named <code>analysis.dat</code> as: </p><pre class="fragment">phi: TORSION ATOMS=5,7,9,15
psi: TORSION ATOMS=7,9,15,17
PRINT ARG=phi,psi FILE=analysis
</pre><p> (see <a class="el" href="_t_o_r_s_i_o_n.html">TORSION</a> and <a class="el" href="_p_r_i_n_t.html">PRINT</a>) Notice that typically when using the driver we do not provide a STRIDE keyword to PRINT. This implies "print at every step" which, analyzing a trajectory, means "print for all the available snapshots". Then, you can use the following command: </p><pre class="fragment">&gt; plumed driver --mf_xtc traj.xtc --plumed analysis.dat
</pre><p> Notice that PLUMED has no way to now the value of physical time from the trajectory. If you want physical time to be printed in the <code>analysis</code> file you should give more information to the driver, e.g.: </p><pre class="fragment">&gt; plumed driver --mf_xtc traj.xtc --plumed analysis.dat --timestep 0.002 --trajectory-stride 1000
</pre><p> (see <a class="el" href="driver.html">driver</a>)</p>
<p>In this case we inform the driver that the <code>traj.xtc</code> file was produced in a run with a timestep of 0.002 ps and saving a snapshop every 1000 timesteps.</p>
<p>You might want to analyze a different collective variable, such as the gyration radius. The gyration radius tells how extended is the molecules in space. You can do it with the following plumed input file</p>
<pre class="fragment">phi: TORSION ATOMS=5,7,9,15
psi: TORSION ATOMS=7,9,15,17

heavy: GROUP ATOMS=1,5,6,7,9,11,15,16,17,19
gyr: GYRATION ATOMS=heavy

# the same could have been achieved with
# gyr: GYRATION ATOMS=1,5,6,7,9,11,15,16,17,19

PRINT ARG=phi,psi,gyr FILE=analyze
</pre><p> (see <a class="el" href="_t_o_r_s_i_o_n.html">TORSION</a>, <a class="el" href="_g_y_r_a_t_i_o_n.html">GYRATION</a>, <a class="el" href="_g_r_o_u_p.html">GROUP</a>, and <a class="el" href="_p_r_i_n_t.html">PRINT</a>)</p>
<p>Now try to compute the time series of the gyration radius.</p>
<p> </div> </details> </p>
<p> <details> <summary> <b> To learn more: Periodic boundaries and explicit water </b> </summary> <div class="hidden">  </p>
<h2><a class="anchor" id="munster-monitor-pbc"></a>
Periodic boundaries and explicit water</h2>
<p>In case you are running the simulation in water, you might see that at some point this variable shows some crazy jump. The reason is that the trajectory containes coordinates where molecules are broken across periodic-boundary conditions This happens with GROMACS and some other MD code. These codes typically have tools to process trajecories and restore whole molecules. This trick is ok for the a-posteriori analysis we are trying now, but cannot used when one needs to compute a collective variable on-the-fly or, as we will see later, one wants to add a bias to that collective variable. For this reason, we implemented a workaround in PLUMED, that is the molecule should be made whole using the <a class="el" href="_w_h_o_l_e_m_o_l_e_c_u_l_e_s.html">WHOLEMOLECULES</a> command. What this command is doing is making a loop over all the atoms (in the order they are provided) and set the coordinates of each of them in the periodic image which is as close as possible to the coordinates of the preceeding atom. In most cases it is sufficient to list all atoms of a molecule in order. Look in the <a class="el" href="_w_h_o_l_e_m_o_l_e_c_u_l_e_s.html">WHOLEMOLECULES</a> page to get more information. Here this will be enough: </p><pre class="fragment">phi: TORSION ATOMS=5,7,9,15
psi: TORSION ATOMS=7,9,15,17

# notice the 1-22 syntax, a shortcut for a list 1,2,3,...,22
WHOLEMOLECULES ENTITY0=1-22

heavy: GROUP ATOMS=1,5,6,7,9,11,15,16,17,19
gyr: GYRATION ATOMS=heavy

PRINT ARG=phi,psi,gyr FILE=analyze
</pre><p> (see <a class="el" href="_t_o_r_s_i_o_n.html">TORSION</a>, <a class="el" href="_w_h_o_l_e_m_o_l_e_c_u_l_e_s.html">WHOLEMOLECULES</a>, <a class="el" href="_g_r_o_u_p.html">GROUP</a>, <a class="el" href="_g_y_r_a_t_i_o_n.html">GYRATION</a>, and <a class="el" href="_p_r_i_n_t.html">PRINT</a>)</p>
<p>This is a very important issue that should be kept in mind when using PLUMED. Notice that starting with version 2.2 PLUMED will make molecules used in <a class="el" href="_g_y_r_a_t_i_o_n.html">GYRATION</a> (as well as in other variables) whole automatically, so that this extra command will not be necessary.</p>
<p>Notice that you can instruct PLUMED to dump on a file not only the collective variables (as we are doing with <a class="el" href="_p_r_i_n_t.html">PRINT</a>) but also the atomic positions. This is a very good way to understand what <a class="el" href="_w_h_o_l_e_m_o_l_e_c_u_l_e_s.html">WHOLEMOLECULES</a> is actually doing. Try the following input</p>
<pre class="fragment">MOLINFO STRUCTURE=../TOPO/reference.pdb
DUMPATOMS FILE=test1.gro ATOMS=1-22
WHOLEMOLECULES ENTITY0=1-22
DUMPATOMS FILE=test2.gro ATOMS=1-22
</pre><p> (see <a class="el" href="_m_o_l_i_n_f_o.html">MOLINFO</a>, <a class="el" href="_d_u_m_p_a_t_o_m_s.html">DUMPATOMS</a>, and <a class="el" href="_w_h_o_l_e_m_o_l_e_c_u_l_e_s.html">WHOLEMOLECULES</a>).</p>
<p><a class="el" href="_d_u_m_p_a_t_o_m_s.html">DUMPATOMS</a> writes on a gro file the coordinates of the alanine dipeptide atoms. Here PLUMED will produce two files, one with coordinates <em>before</em> the application of <a class="el" href="_w_h_o_l_e_m_o_l_e_c_u_l_e_s.html">WHOLEMOLECULES</a>, and one with coordinates after* the application of <a class="el" href="_w_h_o_l_e_m_o_l_e_c_u_l_e_s.html">WHOLEMOLECULES</a>. You can load both trajectories in VMD to see the difference. The <a class="el" href="_m_o_l_i_n_f_o.html">MOLINFO</a> command is here used to provide atom names to PLUMED so that the resulting gro file looks nicer in VMD.</p>
<p>Notice that PLUMED has several commands that manipulate atomic coordinates. One example is <a class="el" href="_w_h_o_l_e_m_o_l_e_c_u_l_e_s.html">WHOLEMOLECULES</a>, that fixes problems with periodic boundary conditions. <a class="el" href="_c_o_m.html">COM</a> and <a class="el" href="_c_e_n_t_e_r.html">CENTER</a> add new atoms, and <a class="el" href="_f_i_t__t_o__t_e_m_p_l_a_t_e.html">FIT_TO_TEMPLATE</a> can actually move atoms from their original position to align them on a template. <a class="el" href="_d_u_m_p_a_t_o_m_s.html">DUMPATOMS</a> is this very useful to check what these commands are doing and for using the PLUMED <a class="el" href="driver.html">driver</a> to manipulate MD trajectories.</p>
<p> </div> </details> </p>
<p> <details> <summary> <b> To learn more: Other analysis tools </b> </summary> <div class="hidden">  </p>
<h2><a class="anchor" id="munster-monitor-an"></a>
Other analysis tools</h2>
<p>PLUMED also allows you to make some analyis on the collective variables you are calculating. For example, you can compute a histogram with an input like this one </p><pre class="fragment">phi: TORSION ATOMS=5,7,9,15
psi: TORSION ATOMS=7,9,15,17
heavy: GROUP ATOMS=1,5,6,7,9,11,15,16,17,19
gyr: GYRATION ATOMS=heavy
PRINT ARG=phi,psi,gyr FILE=analyze
HISTOGRAM ...
  ARG=gyr
  USE_ALL_DATA
  KERNEL=discrete
  GRID_MIN=0
  GRID_MAX=1
  GRID_BIN=50
  GRID_WFILE=histogram
... HISTOGRAM
</pre><p> (see <a class="el" href="_t_o_r_s_i_o_n.html">TORSION</a>, <a class="el" href="_w_h_o_l_e_m_o_l_e_c_u_l_e_s.html">WHOLEMOLECULES</a>, <a class="el" href="_g_r_o_u_p.html">GROUP</a>, <a class="el" href="_g_y_r_a_t_i_o_n.html">GYRATION</a>, <a class="el" href="_p_r_i_n_t.html">PRINT</a>, and <a class="el" href="_h_i_s_t_o_g_r_a_m.html">HISTOGRAM</a>)</p>
<p>An histogram with 50 bins will be performed on the gyration radius. Try to compute the histogram for the \(\Phi\) and \(\Psi\) angles.</p>
<p>PLUMED can do much more than a histogram, more information on analysis can be found at the page <a class="el" href="_analysis.html">Analysis</a></p>
<p>Notice that the plumed driver can also be used directly from VMD taking advantage of the PLUMED collective variable tool developed by Toni Giorgino (<a href="http://multiscalelab.org/utilities/PlumedGUI">http://multiscalelab.org/utilities/PlumedGUI</a>). Just open a recent version of VMD and go to Extensions/Analysis/Collective Variable Analsys (PLUMED). This graphical interface can also be used to quickly build PLUMED input files based on template lines.</p>
<p> </div> </details> </p>
<h1><a class="anchor" id="munster-biasing"></a>
Biasing collective variables</h1>
<p>We have seen that PLUMED can be used to compute collective variables. However, PLUMED is most often use to add forces on the collective variables. To this aim, we have implemented a variety of possible biases acting on collective variables. A bias works in a manner conceptually similar to the <a class="el" href="_p_r_i_n_t.html">PRINT</a> command, taking as argument one or more collective variables. However, here the STRIDE is usually omitted (that is equivalent to setting it to 1), which means that forces are applied at every timestep. In PLUMED 2.2 you will be able to change the STRIDE also for bias potentials, but that's another story. In the following we will see how to apply harmonic restraints and how to build an adaptive bias potential with metadynamics. The complete documentation for all the biasing methods available in PLUMED can be found at the <a class="el" href="_bias.html">Bias</a> page.</p>
<h2><a class="anchor" id="munster-biasing-me"></a>
Metadynamics</h2>
<p> <details> <summary> <b> To learn more: Summary of theory </b> </summary> <div class="hidden">  </p>
<h3><a class="anchor" id="munster-biasing-me-theory"></a>
Summary of theory</h3>
<p>In metadynamics, an external history-dependent bias potential is constructed in the space of a few selected degrees of freedom \( \vec{s}({q}) \), generally called collective variables (CVs) <a class="el" href="citelist.html#CITEREF_metad">[31]</a>. This potential is built as a sum of Gaussians deposited along the trajectory in the CVs space:</p>
<p class="formulaDsp">
\[ V(\vec{s},t) = \sum_{ k \tau &lt; t} W(k \tau) \exp\left( -\sum_{i=1}^{d} \frac{(s_i-s_i({q}(k \tau)))^2}{2\sigma_i^2} \right). \]
</p>
<p>where \( \tau \) is the Gaussian deposition stride, \( \sigma_i \) the width of the Gaussian for the ith CV, and \( W(k \tau) \) the height of the Gaussian. The effect of the metadynamics bias potential is to push the system away from local minima into visiting new regions of the phase space. Furthermore, in the long time limit, the bias potential converges to minus the free energy as a function of the CVs:</p>
<p class="formulaDsp">
\[ V(\vec{s},t\rightarrow \infty) = -F(\vec{s}) + C. \]
</p>
<p>In standard metadynamics, Gaussians of constant height are added for the entire course of a simulation. As a result, the system is eventually pushed to explore high free-energy regions and the estimate of the free energy calculated from the bias potential oscillates around the real value. In well-tempered metadynamics <a class="el" href="citelist.html#CITEREF_Barducci:2008">[4]</a>, the height of the Gaussian is decreased with simulation time according to:</p>
<p class="formulaDsp">
\[ W (k \tau ) = W_0 \exp \left( -\frac{V(\vec{s}({q}(k \tau)),k \tau)}{k_B\Delta T} \right ), \]
</p>
<p>where \( W_0 \) is an initial Gaussian height, \( \Delta T \) an input parameter with the dimension of a temperature, and \( k_B \) the Boltzmann constant. With this rescaling of the Gaussian height, the bias potential smoothly converges in the long time limit, but it does not fully compensate the underlying free energy:</p>
<p class="formulaDsp">
\[ V(\vec{s},t\rightarrow \infty) = -\frac{\Delta T}{T+\Delta T}F(\vec{s}) + C. \]
</p>
<p>where \( T \) is the temperature of the system. In the long time limit, the CVs thus sample an ensemble at a temperature \( T+\Delta T \) which is higher than the system temperature \( T \). The parameter \( \Delta T \) can be chosen to regulate the extent of free-energy exploration: \( \Delta T = 0\) corresponds to standard molecular dynamics, \( \Delta T \rightarrow \infty \) to standard metadynamics. In well-tempered metadynamics literature and in PLUMED, you will often encounter the term "biasfactor" which is the ratio between the temperature of the CVs ( \( T+\Delta T \)) and the system temperature ( \( T \)):</p>
<p class="formulaDsp">
\[ \gamma = \frac{T+\Delta T}{T}. \]
</p>
<p>The biasfactor should thus be carefully chosen in order for the relevant free-energy barriers to be crossed efficiently in the time scale of the simulation.</p>
<p>Additional information can be found in the several review papers on metadynamics <a class="el" href="citelist.html#CITEREF_gerv-laio09review">[30]</a> <a class="el" href="citelist.html#CITEREF_WCMS:WCMS31">[5]</a> <a class="el" href="citelist.html#CITEREF_WCMS:WCMS1103">[45]</a>.</p>
<p> </div> </details> </p>
<p>If you do not know exactly where you would like your collective variables to go, and just know (or suspect) that some variables have large free-energy barriers that hinder some conformational rearrangement or some chemical reaction, you can bias them using metadynamics. In this way, a time dependent, adaptive potential will be constructed that tends to disfavor visited configurations in the collective-variable space. The bias is usually built as a sum of Gaussian deposited in the already visited states.</p>
<h3><a class="anchor" id="munster-exercise-1"></a>
Exercise 1</h3>
<p>Now run a metadynamics simulation with the following input </p><pre class="fragment">phi: TORSION ATOMS=5,7,9,15
psi: TORSION ATOMS=7,9,15,17
METAD ARG=phi,psi HEIGHT=1.0 BIASFACTOR=10 SIGMA=0.35,0.35 PACE=100 GRID_MIN=-pi,-pi GRID_MAX=pi,pi
</pre><p> (see <a class="el" href="_t_o_r_s_i_o_n.html">TORSION</a> and <a class="el" href="_m_e_t_a_d.html">METAD</a>) Thus, a single METAD line will contain all the metadynamics related options, such as Gaussian height (<code>HEIGHT</code>, here in kJ/mol), stride (<code>PACE</code>, here in number of time steps), bias factor (<code>BIASFACTOR</code>, here indicates that we are going to effectively boost the temperature of the collective variables by a factor 10), and width (<code>SIGMA</code>, an array with same size as the number of collective variables).</p>
<p>There are two additional keywords that are optional, namely GRID_MIN and GRID_MAX. These keywords sets the range of the collective variables and tell PLUMED to keep the bias potential stored on a grid. This affects speed but, in principle, not the accuracy of the calculation. You can try to remove those keywords and see the difference.</p>
<p>Now, run a metadynamics simulations and check the explored collective variable space. Results from a 200ps (100000 steps) trajectory in vacuum are shown in Figure <a class="el" href="munster.html#munster-ala-traj-metad">munster-ala-traj-metad</a>.</p>
<p><a class="anchor" id="munster-ala-traj-metad"></a></p><div class="image">
<img src="munster-ala-traj-metad.png" alt="munster-ala-traj-metad.png"/>
<div class="caption">
(phi,psi) scatter plot obtained with metadynamics and two different values of the biasfactor. Simulation performed in vacuum.</div></div>
<p> As you can see, exploration is greatly enhanced. Notice that the explored ensemble can be tuned using the biasfactor \(\gamma\). Larger \(\gamma\) implies that the system will explore states with higher free energy. As a rule of thumb, if you expect a barrier of the order of \(\Delta G^*\), a reasonable choice for the biasfactor is \(\gamma\approx\frac{\Delta G}{2k_BT}\).</p>
<p>Finally, notice that <a class="el" href="_m_e_t_a_d.html">METAD</a> potential depends on the previously visited trajectories. As such, when you restart a previous simulation, it should read the previously deposited HILLS file. This is automatically triggered by the <a class="el" href="_r_e_s_t_a_r_t.html">RESTART</a> keyword.</p>
<h3><a class="anchor" id="munster-exercise-2"></a>
Exercise 2</h3>
<p>In this exercise, we will run a well-tempered metadynamics simulation on alanine dipeptide in vacuum, using as CV the backbone dihedral angle phi. In order to run this simulation we need to prepare the PLUMED input file (plumed.dat) as follows.</p>
<pre class="fragment"># set up two variables for Phi and Psi dihedral angles 
phi: TORSION ATOMS=5,7,9,15
psi: TORSION ATOMS=7,9,15,17
#
# Activate well-tempered metadynamics in phi depositing 
# a Gaussian every 500 time steps, with initial height equal 
# to 1.2 kJoule/mol, biasfactor equal to 10.0, and width to 0.35 rad

METAD ...
LABEL=metad
ARG=phi
PACE=500
HEIGHT=1.2
SIGMA=0.35
FILE=HILLS
BIASFACTOR=10.0
TEMP=300.0
GRID_MIN=-pi
GRID_MAX=pi
GRID_SPACING=0.1
... METAD

# monitor the two variables and the metadynamics bias potential
PRINT STRIDE=10 ARG=phi,psi,metad.bias FILE=COLVAR</pre><p> (see <a class="el" href="_t_o_r_s_i_o_n.html">TORSION</a>, <a class="el" href="_m_e_t_a_d.html">METAD</a>, and <a class="el" href="_p_r_i_n_t.html">PRINT</a>).</p>
<p>The syntax for the command <a class="el" href="_m_e_t_a_d.html">METAD</a> is simple. The directive is followed by a keyword ARG followed by the labels of the CVs on which the metadynamics potential will act. The keyword PACE determines the stride of Gaussian deposition in number of time steps, while the keyword HEIGHT specifies the height of the Gaussian in kJoule/mol. For each CVs, one has to specified the width of the Gaussian by using the keyword SIGMA. Gaussian will be written to the file indicated by the keyword FILE.</p>
<p>The bias potential will be stored on a grid, whose boundaries are specified by the keywords GRID_MIN and GRID_MAX. Notice that you should provide either the number of bins for every collective variable (GRID_BIN) or the desired grid spacing (GRID_SPACING). In case you provide both PLUMED will use the most conservative choice (highest number of bins) for each dimension. In case you do not provide any information about bin size (neither GRID_BIN nor GRID_SPACING) and if Gaussian width is fixed PLUMED will use 1/5 of the Gaussian width as grid spacing. This default choice should be reasonable for most applications.</p>
<p>Once the PLUMED input file is prepared, one has to run Gromacs with the option to activate PLUMED and read the input file:</p>
<pre class="fragment">mdrun_mpi -s ../TOPO/topolA.tpr -plumed plumed.dat -nsteps 5000000
</pre><p>During the metadynamics simulation, PLUMED will create two files, named COLVAR and HILLS. The COLVAR file contains all the information specified by the PRINT command, in this case the value of the CVs every 10 steps of simulation, along with the current value of the metadynamics bias potential. We can use COLVAR to visualize the behavior of the CV during the simulation:</p>
<p><a class="anchor" id="munster-metad-phi-fig"></a></p><div class="image">
<img src="munster-metad-phi.png" alt="munster-metad-phi.png"/>
<div class="caption">
Time evolution of the CV phi during the first 2 ns of a metadynamics simulation of alanine dipeptide in vacuum.</div></div>
<p> By inspecting Figure <a class="el" href="munster.html#munster-metad-phi-fig">munster-metad-phi-fig</a>, we can see that the system is initialized in one of the two metastable states of alanine dipeptide. After a while (t=0.1 ns), the system is pushed by the metadynamics bias potential to visit the other local minimum. As the simulation continues, the bias potential fills the underlying free-energy landscape, and the system is able to diffuse in the entire phase space.</p>
<p>The HILLS file contains a list of the Gaussians deposited along the simulation. If we give a look at the header of this file, we can find relevant information about its content:</p>
<pre class="fragment">#! FIELDS time phi psi sigma_phi sigma_psi height biasf
#! SET multivariate false
#! SET min_phi -pi
#! SET max_phi pi
#! SET min_psi -pi
#! SET max_psi pi
</pre><p>The line starting with FIELDS tells us what is displayed in the various columns of the HILLS file: the time of the simulation, the value of phi and psi, the width of the Gaussian in phi and psi, the height of the Gaussian, and the biasfactor. We can use the HILLS file to visualize the decrease of the Gaussian height during the simulation, according to the well-tempered recipe:</p>
<p><a class="anchor" id="munster-metad-phihills-fig"></a></p><div class="image">
<img src="munster-metad-phihills.png" alt="munster-metad-phihills.png"/>
<div class="caption">
Time evolution of the Gaussian height.</div></div>
<p> If we look carefully at the scale of the y-axis, we will notice that in the beginning the value of the Gaussian height is higher than the initial height specified in the input file, which should be 1.2 kJoule/mol. In fact, this column reports the height of the Gaussian rescaled by the pre-factor that in well-tempered metadynamics relates the bias potential to the free energy. In this way, when we will use <a class="el" href="sum_hills.html">sum_hills</a>, the sum of the Gaussians deposited will directly provide the free-energy, without further rescaling needed (see below).</p>
<p>One can estimate the free energy as a function of the metadynamics CVs directly from the metadynamics bias potential. In order to do so, the utility <a class="el" href="sum_hills.html">sum_hills</a> should be used to sum the Gaussians deposited during the simulation and stored in the HILLS file. To calculate the free energy as a function of phi, it is sufficient to use the following command line:</p>
<pre class="fragment">plumed sum_hills --hills HILLS
</pre><p>The command above generates a file called fes.dat in which the free-energy surface as function of phi is calculated on a regular grid. One can modify the default name for the free energy file, as well as the boundaries and bin size of the grid, by using the following options of <a class="el" href="sum_hills.html">sum_hills</a> :</p>
<pre class="fragment">--outfile - specify the outputfile for sumhills
--min - the lower bounds for the grid
--max - the upper bounds for the grid
--bin - the number of bins for the grid
--spacing - grid spacing, alternative to the number of bins
</pre><p>The result should look like this:</p>
<p><a class="anchor" id="munster-metad-phifes-fig"></a></p><div class="image">
<img src="munster-metad-phifes.png" alt="munster-metad-phifes.png"/>
<div class="caption">
Estimate of the free energy as a function of the dihedral phi from a 10ns-long well-tempered metadynamics simulation.</div></div>
<p> To assess the convergence of a metadynamics simulation, one can calculate the estimate of the free energy as a function of simulation time. At convergence, the reconstructed profiles should be similar. The option &ndash;stride should be used to give an estimate of the free energy every N Gaussians deposited, and the option &ndash;mintozero can be used to align the profiles by setting the global minimum to zero. If we use the following command line:</p>
<pre class="fragment">plumed sum_hills --hills HILLS --stride 100 --mintozero
</pre><p>one free energy is calculated every 100 Gaussians deposited, and the global minimum is set to zero in all profiles. The resulting plot should look like the following:</p>
<p><a class="anchor" id="munster-metad-phifest-fig"></a></p><div class="image">
<img src="munster-metad-phifest.png" alt="munster-metad-phifest.png"/>
<div class="caption">
Estimates of the free energy as a function of the dihedral phi calculated every 100 Gaussians deposited.</div></div>
<p> To assess the convergence of the simulation more quantitatively, we can calculate the free-energy difference between the two local minima of the free energy along phi as a function of simulation time. We can use following script to integrate the multiple free-energy profiles in the two basins defined by the following intervals in phi space: basin A, -3&lt;phi&lt;-1, basin B, 0.5&lt;phi&lt;1.5.</p>
<pre class="fragment"># number of free-energy profiles
nfes= # put here the number of profiles
# minimum of basin A
minA=-3
# maximum of basin A
maxA=1
# minimum of basin B
minB=0.5
# maximum of basin B
maxB=1.5
# temperature in energy units
kbt=2.5

for((i=0;i&lt;nfes;i++))
do
 # calculate free-energy of basin A
 A=`awk 'BEGIN{tot=0.0}{if($1!="#!" &amp;&amp; $1&gt;min &amp;&amp; $1&lt;max)tot+=exp(-$2/kbt)}END{print -kbt*log(tot)}' min=${minA} max=${maxA} kbt=${kbt} fes_${i}.dat`
 # and basin B
 B=`awk 'BEGIN{tot=0.0}{if($1!="#!" &amp;&amp; $1&gt;min &amp;&amp; $1&lt;max)tot+=exp(-$2/kbt)}END{print -kbt*log(tot)}' min=${minB} max=${maxB} kbt=${kbt} fes_${i}.dat`
 # calculate difference
 Delta=$(echo "${A} - ${B}" | bc -l)
 # print it
 echo $i $Delta
done</pre><p>notice that nfes should be set to the number of profiles (free-energy estimates at different times of the simulation) generated by the option &ndash;stride of <a class="el" href="sum_hills.html">sum_hills</a>.</p>
<p><a class="anchor" id="munster-metad-phifes-difft-fig"></a></p><div class="image">
<img src="munster-metad-phifes-difft.png" alt="munster-metad-phifes-difft.png"/>
<div class="caption">
Free-energy difference between basin A and B as a function of simulation time.</div></div>
<p> This analysis, along with the observation of the diffusive behavior in the CVs space, suggest that the simulation is converged.</p>
<h3><a class="anchor" id="munster-exercise-3"></a>
Exercise 3</h3>
<p>In this exercise, we will run a well-tempered metadynamics simulation on alanine dipeptide in vacuum, using as CV the backbone dihedral angle psi. In order to run this simulation we need to prepare the PLUMED input file (plumed.dat) as follows.</p>
<pre class="fragment"># set up two variables for Phi and Psi dihedral angles 
phi: TORSION ATOMS=5,7,9,15
psi: TORSION ATOMS=7,9,15,17
#
# Activate well-tempered metadynamics in psi depositing 
# a Gaussian every 500 time steps, with initial height equal 
# to 1.2 kJoule/mol, biasfactor equal to 10.0, and width to 0.35 rad

METAD ...
LABEL=metad
ARG=psi
PACE=500
HEIGHT=1.2
SIGMA=0.35
FILE=HILLS
BIASFACTOR=10.0
TEMP=300.0
GRID_MIN=-pi
GRID_MAX=pi
GRID_SPACING=0.1
... METAD

# monitor the two variables and the metadynamics bias potential
PRINT STRIDE=10 ARG=phi,psi,metad.bias FILE=COLVAR</pre><p> (see <a class="el" href="_t_o_r_s_i_o_n.html">TORSION</a>, <a class="el" href="_m_e_t_a_d.html">METAD</a>, and <a class="el" href="_p_r_i_n_t.html">PRINT</a>).</p>
<p>Once the PLUMED input file is prepared, one has to run Gromacs with the option to activate PLUMED and read the input file:</p>
<pre class="fragment">mdrun_mpi -s ../TOPO/topolA.tpr -plumed plumed.dat -nsteps 5000000
</pre><p>As we did in the previous exercise, we can use COLVAR to visualize the behavior of the CV during the simulation. Here we will plot at the same time the evolution of the metadynamics CV psi and of the other dihedral phi:</p>
<p><a class="anchor" id="munster-metad-psi-phi-fig"></a></p><div class="image">
<img src="munster-metad-psi-phi.png" alt="munster-metad-psi-phi.png"/>
<div class="caption">
Time evolution of the dihedrals phi and psi during a 10-ns long metadynamics simulation using psi as CV.</div></div>
<p> By inspecting Figure <a class="el" href="munster.html#munster-metad-psi-phi-fig">munster-metad-psi-phi-fig</a>, we notice that something different happened compared to the previous exercise. At first the behavior of psi looks diffusive in the entire CV space. However, around t=1 ns, psi seems trapped in a region of the CV space in which it was previously diffusing without problems. The reason is that the non-biased CV phi after a while has jumped into a different local minima. Since phi is not directly biased, one has to wait for this (slow) degree of freedom to equilibrate before the free energy along psi can converge. Try to repeat the analysis done in the previous exercise (calculate the estimate of the free energy as a function of time and monitor the free-energy difference between basins) to assess the convergence of this metadynamics simulation.</p>
<h2><a class="anchor" id="munster-biasing-re"></a>
Restraints</h2>
<p> <details> <summary> <b> To learn more: Biased sampling theory </b> </summary> <div class="hidden">  </p>
<h3><a class="anchor" id="munster-biased-sampling-theory"></a>
Biased sampling theory</h3>
<p>A system at temperature \( T\) samples conformations from the canonical ensemble: </p><p class="formulaDsp">
\[ P(q)\propto e^{-\frac{U(q)}{k_BT}} \]
</p>
<p>. Here \( q \) are the microscopic coordinates and \( k_B \) is the Boltzmann constant. Since \( q \) is a highly dimensional vector, it is often convenient to analyze it in terms of a few collective variables (see <a class="el" href="belfast-1.html">Belfast tutorial: Analyzing CVs</a> , <a class="el" href="belfast-2.html">Belfast tutorial: Adaptive variables I</a> , and <a class="el" href="belfast-3.html">Belfast tutorial: Adaptive variables II</a> ). The probability distribution for a CV \( s\) is </p><p class="formulaDsp">
\[ P(s)\propto \int dq e^{-\frac{U(q)}{k_BT}} \delta(s-s(q)) \]
</p>
<p> This probability can be expressed in energy units as a free energy landscape \( F(s) \): </p><p class="formulaDsp">
\[ F(s)=-k_B T \log P(s) \]
</p>
<p>.</p>
<p>Now we would like to modify the potential by adding a term that depends on the CV only. That is, instead of using \( U(q) \), we use \( U(q)+V(s(q))\). There are several reasons why one would like to introduce this potential. One is to avoid that the system samples some un-desired portion of the conformational space. As an example, imagine that you want to study dissociation of a complex of two molecules. If you perform a very long simulation you will be able to see association and dissociation. However, the typical time required for association will depend on the size of the simulation box. It could be thus convenient to limit the exploration to conformations where the distance between the two molecules is lower than a given threshold. This could be done by adding a bias potential on the distance between the two molecules. Another example is the simulation of a portion of a large molecule taken out from its initial context. The fragment alone could be unstable, and one might want to add additional potentials to keep the fragment in place. This could be done by adding a bias potential on some measure of the distance from the experimental structure (e.g. on root-mean-square deviation).</p>
<p>Whatever CV we decide to bias, it is very important to recognize which is the effect of this bias and, if necessary, remove it a posteriori. The biased distribution of the CV will be </p><p class="formulaDsp">
\[ P&#39;(s)\propto \int dq e^{-\frac{U(q)+V(s(q))}{k_BT}} \delta(s-s(q))\propto e^{-\frac{V(s(q))}{k_BT}}P(s) \]
</p>
<p> and the biased free energy landscape </p><p class="formulaDsp">
\[ F&#39;(s)=-k_B T \log P&#39;(s)=F(s)+V(s)+C \]
</p>
<p> Thus, the effect of a bias potential on the free energy is additive. Also notice the presence of an undetermined constant \( C \). This constant is irrelevant for what concerns free-energy differences and barriers, but will be important later when we will learn the weighted-histogram method. Obviously the last equation can be inverted so as to obtain the original, unbiased free-energy landscape from the biased one just subtracting the bias potential </p><p class="formulaDsp">
\[ F(s)=F&#39;(s)-V(s)+C \]
</p>
<p>Additionally, one might be interested in recovering the distribution of an arbitrary observable. E.g., one could add a bias on the distance between two molecules and be willing to compute the unbiased distribution of some torsional angle. In this case there is no straightforward relationship that can be used, and one has to go back to the relationship between the microscopic probabilities: </p><p class="formulaDsp">
\[ P(q)\propto P&#39;(q) e^{\frac{V(s(q))}{k_BT}} \]
</p>
<p> The consequence of this expression is that one can obtained any kind of unbiased information from a biased simulation just by weighting every sampled conformation with a weight </p><p class="formulaDsp">
\[ w\propto e^{\frac{V(s(q))}{k_BT}} \]
</p>
<p> That is, frames that have been explored in spite of a high (disfavoring) bias potential \( V \) will be counted more than frames that has been explored with a less disfavoring bias potential.</p>
<p> </div> </details> </p>
<p> <details> <summary> <b> To learn more: Umbrella sampling theory </b> </summary> <div class="hidden">  </p>
<h3><a class="anchor" id="munster-umbrella-sampling-theory"></a>
Umbrella sampling theory</h3>
<p>Often in interesting cases the free-energy landscape has several local minima. If these minima have free-energy differences that are on the order of a few times \(k_BT\) they might all be relevant. However, if they are separated by a high saddle point in the free-energy landscape (i.e. a low probability region) than the transition between one and the other will take a lot of time and these minima will correspond to metastable states. The transition between one minimum and the other could require a time scale which is out of reach for molecular dynamics. In these situations, one could take inspiration from catalysis and try to favor in a controlled manner the conformations corresponding to the transition state.</p>
<p>Imagine that you know since the beginning the shape of the free-energy landscape \( F(s) \) as a function of one CV \( s \). If you perform a molecular dynamics simulation using a bias potential which is exactly equal to \( -F(s) \), the biased free-energy landscape will be flat and barrierless. This potential acts as an "umbrella" that helps you to safely cross the transition state in spite of its high free energy.</p>
<p>It is however difficult to have an a priori guess of the free-energy landscape. We will see later how adaptive techniques such as metadynamics (<a class="el" href="belfast-6.html">Belfast tutorial: Metadynamics</a>) can be used to this aim. Because of this reason, umbrella sampling is often used in a slightly different manner.</p>
<p>Imagine that you do not know the exact height of the free-energy barrier but you have an idea of where the barrier is located. You could try to just favor the sampling of the transition state by adding a harmonic restraint on the CV, e.g. in the form </p><p class="formulaDsp">
\[ V(s)=\frac{k}{2} (s-s_0)^2 \]
</p>
<p>. The sampled distribution will be </p><p class="formulaDsp">
\[ P&#39;(q)\propto P(q) e^{\frac{-k(s(q)-s_0)^2}{2k_BT}} \]
</p>
<p> For large values of \( k \), only points close to \( s_0 \) will be explored. It is thus clear how one can force the system to explore only a predefined region of the space adding such a restraint. By combining simulations performed with different values of \( s_0 \), one could obtain a continuous set of simulations going from one minimum to the other crossing the transition state. In the next section we will see how to combine the information from these simulations.</p>
<p> </div> </details> </p>
<p>If you want to just bring a collective variables to a specific value, you can use a simple restraint. Let's imagine that we want to force the \(\Phi\) angle to visit a region close to \(\Phi=\pi/2\). We can do it adding a restraint in \(\Phi\), with the following input </p><pre class="fragment">phi: TORSION ATOMS=5,7,9,15
psi: TORSION ATOMS=7,9,15,17
res: RESTRAINT ARG=phi AT=0.5pi KAPPA=5
PRINT ARG=phi,psi,res.bias
</pre><p> (see <a class="el" href="_t_o_r_s_i_o_n.html">TORSION</a>, <a class="el" href="_r_e_s_t_r_a_i_n_t.html">RESTRAINT</a>, and <a class="el" href="_p_r_i_n_t.html">PRINT</a>).</p>
<p>Notice that here we are printing a quantity named <code>res.bias</code>. We do this because <a class="el" href="_r_e_s_t_r_a_i_n_t.html">RESTRAINT</a> does not define a single value (that here would be theoretically named <code>res</code>) but a structure with several components. All biasing methods (including <a class="el" href="_m_e_t_a_d.html">METAD</a>) do so, as well as many collective variables (see e.g. <a class="el" href="_d_i_s_t_a_n_c_e.html">DISTANCE</a> used with COMPONENTS keyword). Printing the bias allows one to know how much a given snapshop was penalized. Also notice that PLUMED understands numbers in the for <code>{number}pi</code>. This is convenient when using torsions, since they are expressed in radians.</p>
<p>Now you can plot your trajectory with gnuplot and see the effect of KAPPA. You can also try different values of KAPPA. The stiffer the restraint, the less the collective variable will fluctuate. However, notice that a too large kappa could make the MD integrator unstable.</p>
<p> <details> <summary> <b> To learn more: Moving restraints </b> </summary> <div class="hidden">  </p>
<h2><a class="anchor" id="munster-biasing-moving"></a>
Moving restraints</h2>
<p>A restraint can also be modified as a function of time. For example, if you want to bring the system from one minimum to the other, you can use a moving restraint on \(\Phi\): </p><pre class="fragment">phi: TORSION ATOMS=5,7,9,15
psi: TORSION ATOMS=7,9,15,17
# notice that a long line can be splitted with this syntax
MOVINGRESTRAINT ...
# also notice that a LABEL keyword can be used and is equivalent
# to adding the name at the beginning of the line with colon, as we did so far
  LABEL=res
  ARG=phi
  STEP0=0 AT0=-0.5pi KAPPA0=5
  STEP1=10000 AT0=0.5pi 
...
PRINT ARG=phi,psi,res.work,res.phi_cntr FILE=colvar
</pre><p> (see <a class="el" href="_t_o_r_s_i_o_n.html">TORSION</a>, <a class="el" href="_m_o_v_i_n_g_r_e_s_t_r_a_i_n_t.html">MOVINGRESTRAINT</a>, and <a class="el" href="_p_r_i_n_t.html">PRINT</a>).</p>
<p>Notice that here we are plotting a few new components, namely <code>work</code> and <code>phi_cntr</code>. The former gives the work performed in pulling the restraint, and the latter the position of the restraint. Notice that if pulling is slow enough one can compute free energy profile from the work. You can plot the putative free-energy landscape with </p><pre class="fragment">&gt; gnuplot
# column 5 is res.phi_cntr
# column 4 is res.work
gnuplot&gt; p "colvar" u 5:4
</pre><p> </div> </details> </p>
<h2><a class="anchor" id="munster-multi"></a>
Using multiple replicas</h2>
<dl class="section warning"><dt>Warning</dt><dd>Notice that multireplica simulations with PLUMED are fully supported with GROMACS, but only partly supported with other MD engines.</dd></dl>
<p>Some free-energy methods are intrinsically parallel and requires running several simultaneous simulations. This can be done with gromacs using the multi replica framework. That is, if you have 4 tpr files named topol0.tpr, topol1.tpr, topol2.tpr, topol3.tpr you can run 4 simultaneous simulations. </p><pre class="fragment">&gt; mpirun -np 4 mdrun_mpi -s topol.tpr -plumed plumed.dat -multi 4 -nsteps 500000
</pre><p> Each of the 4 replicas will open a different topol file, and GROMACS will take care of adding the replica number before the .tpr suffix. PLUMED deals with the extra number in a slightly different way. In this case, for example, PLUMED first look for a file named <code>plumed.dat.X</code>, where X is the number of the replica. In case the file is not found, then PLUMED looks for <code>plumed.dat</code>. If also this is not found, PLUMED will complain. As a consequence, if all the replicas should use the same input file it is sufficient to put a single <code>plumed.dat</code> file, but one has also the flexibility of using separate files named <code>plumed.dat.0</code>, <code>plumed.dat.1</code> etc. Finally, notice that the way PLUMED adds suffixes will change in version 2.2, and names will be <code>plumed.0.dat</code> etc.</p>
<p>Also notice that providing the flag <code>-replex</code> one can instruct gromacs to perform a replica exchange simulation. Namely, from time to time gromacs will try to swap coordinates among neighboring replicas and accept of reject the exchange with a Monte Carlo procedure which also takes into account the bias potentials acting on the replicas, even if different bias potentials are used in different replicas. That is, PLUMED allows to easily implement many forms of Hamiltonian replica exchange.</p>
<h2><a class="anchor" id="munster-multi-wham"></a>
Using multiple restraints with replica exchange</h2>
<p> <details> <summary> <b> To learn more: Weighted histogram analysis method theory </b> </summary> <div class="hidden">  </p>
<h3><a class="anchor" id="munster-wham-theory"></a>
Weighted histogram analysis method theory</h3>
<p>Let's now consider multiple simulations performed with restraints located in different positions. In particular, we will consider the \(i\)-th bias potential as \(V_i\). The probability to observe a given value of the collective variable \(s\) is: </p><p class="formulaDsp">
\[ P_i({s})=\frac{P({s})e^{-\frac{V_i({s})}{k_BT}}}{\int ds&#39; P({s}&#39;) e^{-\frac{V_i({s}&#39;)}{k_BT}}}= \frac{P({s})e^{-\frac{V_i({s})}{k_BT}}}{Z_i} \]
</p>
<p> where </p><p class="formulaDsp">
\[ Z_i=\sum_{q}e^{-\left(U(q)+V_i(q)\right)} \]
</p>
<p> The likelyhood for the observation of a sequence of snapshots \(q_i(t)\) (where \(i\) is the index of the trajectory and \(t\) is time) is just the product of the probability of each of the snapshots. We use here the minus-logarithm of the likelihood (so that the product is converted to a sum) that can be written as </p><p class="formulaDsp">
\[ \mathcal{L}=-\sum_i \int dt \log P_i({s}_i(t))= \sum_i \int dt \left( -\log P({s}_i(t)) +\frac{V_i({s}_i(t))}{k_BT} +\log Z_i \right) \]
</p>
<p> One can then maximize the likelyhood by setting \(\frac{\delta \mathcal{L}}{\delta P({\bf s})}=0\). After some boring algebra the following expression can be obtained </p><p class="formulaDsp">
\[ 0=\sum_{i}\int dt\left(-\frac{\delta_{{\bf s}_{i}(t),{\bf s}}}{P({\bf s})}+\frac{e^{-\frac{V_{i}({\bf s})}{k_{B}T}}}{Z_{i}}\right) \]
</p>
<p> In this equation we aim at finding \(P(s)\). However, also the list of normalization factors \(Z_i\) is unknown, and they should be found selfconsistently. Thus one can find the solution as </p><p class="formulaDsp">
\[ P({\bf s})\propto \frac{N({\bf s})}{\sum_i\int dt\frac{e^{-\frac{V_{i}({\bf s})}{k_{B}T}}}{Z_{i}} } \]
</p>
<p> where \(Z\) is selfconsistently determined as </p><p class="formulaDsp">
\[ Z_i\propto\int ds&#39; P({\bf s}&#39;) e^{-\frac{V_i({\bf s}&#39;)}{k_BT}} \]
</p>
<p>These are the WHAM equations that are traditionally solved to derive the unbiased probability \(P(s)\) by the combination of multiple restrained simulations. To make a slightly more general implementation, one can compute the weights that should be assigned to each snapshot, that turn out to be: </p><p class="formulaDsp">
\[ w_i(t)\propto \frac{1}{\sum_j\int dt\frac{e^{-\beta V_{j}({\bf s}_i(t))}}{Z_{j}} } \]
</p>
<p> The normalization factors can in turn be found from the weights as </p><p class="formulaDsp">
\[ Z_i\propto\frac{\sum_j \int dt e^{-\beta V_i({\bf s}_j(t))} w_j(t)}{ \sum_j \int dt w_j(t)} \]
</p>
<p>This allows to straighforwardly compute averages related to other, non-biased degrees of freedom, and it is thus a bit more flexible. It is sufficient to precompute this factors \(w\) and use them to weight every single frame in the trajectory.</p>
<p> </div> </details> </p>
<h3><a class="anchor" id="munster-exercise-4"></a>
Exercise 4</h3>
<p>In this exercise we will run multiple restraint simulations and learn how to reweight and combine data with WHAM to obtain free-energy profiles. We start with running in a replica-exchange scheme 32 simulations with a restraint on phi in different positions, ranging from -3 to 3. We will instruct gromacs to attempt an exchange between different simulations every 1000 steps.</p>
<pre class="fragment">nrep=32
dx=`echo "6.0 / ( $nrep - 1 )" | bc -l`

for((i=0;i&lt;nrep;i++))
do
# center of the restraint
AT=`echo "$i * $dx - 3.0" | bc -l`

cat &gt;plumed.dat.$i &lt;&lt; EOF
phi: TORSION ATOMS=5,7,9,15
psi: TORSION ATOMS=7,9,15,17
#
# Impose an umbrella potential on phi
# with a spring constant of 200 kjoule/mol
# and centered in phi=AT
#
restraint-phi: RESTRAINT ARG=phi KAPPA=200.0 AT=$AT
# monitor the two variables and the bias potential
PRINT STRIDE=100 ARG=phi,psi,restraint-phi.bias FILE=COLVAR
EOF

# we initialize some replicas in A and some in B:
if((i%2==0)); then
  cp ../TOPO/topolA.tpr topol$i.tpr
else
  cp ../TOPO/topolB.tpr topol$i.tpr
fi
done

# run REM
mpirun -np $nrep mdrun_mpi -plumed plumed.dat -s topol.tpr -multi $nrep -replex 1000 -nsteps 500000
</pre><p>To be able to combine data from all the simulations, it is necessary to have an overlap between statistics collected in two adjacent umbrellas. Have a look at the plot of (phi,psi) for the different simulations to understand what is happening.</p>
<p><a class="anchor" id="munster-usrem-phi-all"></a></p><div class="image">
<img src="munster-usrem-phi-all.png" alt="munster-usrem-phi-all.png"/>
<div class="caption">
(phi,psi) scatter plot from the multiple restraints simulation.</div></div>
<p> An often misunderstood fact about WHAM is that data of the different trajectories can be mixed and it is not necessary to keep track of which restraint was used to produce every single frame. Let's get the concatenated trajectory</p>
<pre class="fragment">trjcat_mpi -cat -f traj*.xtc -o alltraj.xtc
</pre><p>Now we should compute the value of each of the bias potentials on the entire (concatenated) trajectory.</p>
<pre class="fragment">nrep=32
dx=`echo "6.0 / ( $nrep - 1 )" | bc -l`

for i in `seq 0 $(( $nrep - 1 ))`
do
# center of the restraint
AT=`echo "$i * $dx - 3.0" | bc -l`

cat &gt;plumed.dat &lt;&lt; EOF
phi: TORSION ATOMS=5,7,9,15
psi: TORSION ATOMS=7,9,15,17
restraint-phi: RESTRAINT ARG=phi KAPPA=200.0 AT=$AT

# monitor the two variables and the bias potential
PRINT STRIDE=100 ARG=phi,psi,restraint-phi.bias FILE=ALLCOLVAR.$i
EOF

plumed driver --mf_xtc alltraj.xtc --trajectory-stride=10 --plumed plumed.dat

done
</pre><p>It is very important that this script is consistent with the one used to generate the multiple simulations above. Now, single files named ALLCOLVAR.XX will contain on the fourth column the value of the bias centered in a given position, computed on the entire concatenated trajectory.</p>
<p>Next step is to compute the weights self-consistently solving the WHAM equations, using the python script "wham.py" contained in the SCRIPTS directory. To use this code:</p>
<pre class="fragment">../SCRIPTS/wham.sh ALLCOLVAR.*
</pre><p>This script will produce several files. Let's visualize "phi_fes.dat", which contains the free energy as a function of phi, and compare this with the result previously obtained with metadynamics.</p>
<p><a class="anchor" id="munster-usrem-phi-fes"></a></p><div class="image">
<img src="munster-usrem-phi-fes.png" alt="munster-usrem-phi-fes.png"/>
<div class="caption">
Free energy as a function of phi from multiple restraint (US-REM) and metadynamics (MetaD) simulations.</div></div>
<h3><a class="anchor" id="munster-exercise-5"></a>
Exercise 5</h3>
<p>In the previous exercise, we use multiple restraint simulations to calculate the free energy as a function of the dihedral phi. The resulting free energy was in excellent agreement with our previous metadynamics simulation. In this exercise we will repeat the same procedure for the dihedral psi. At the end of the steps defined above, we can plot the free energy "psi_fes.dat" and compare it with the reference profile calculated from a metadynamics simulations using both phi and psi as CVs.</p>
<p><a class="anchor" id="munster-usrem-psi-fes"></a></p><div class="image">
<img src="munster-usrem-psi-fes.png" alt="munster-usrem-psi-fes.png"/>
<div class="caption">
Free energy as a function of psi from multiple restraint (US-REM) and metadynamics (MetaD) simulations.</div></div>
<p> We can easily spot from the plot above that something went wrong in this multiple restraint simulations, despite we used the very same approach we adopted for the phi dihedral. The problem here is that psi is a "bad" collective variable, and the system is not able to equilibrate the missing slow degree of freedom phi in the short time scale of the umbrella simulation (1 ns). In the metadynamics exercise in which we biased only psi, we detect problems by observing the behavior of the CV as a function of simulation time. How can we detect problems in multiple restraint simulations? This is slightly more complicated, but running this kind of simulation in a replica-exchange scheme offers a convenient way to detect problems.</p>
<p>The first thing we need to do is to demux the replica-exchange trajectories and reconstruct the continous trajectories of the replicas across the different restraint potentials. In order to do so, we can use the following script:</p>
<pre class="fragment">demux.pl md0.log
trjcat_mpi -f traj*.xtc  -demux replica_index.xvg
</pre><p>This commands will generate 32 continous trajectories, named XX_trajout.xtc. We will use the driver to calculate the value of the CVs phi and psi on these trajectories.</p>
<pre class="fragment">nrep=32

for i in `seq 0 $(( $nrep - 1 ))`
do

cat &gt;plumed.dat &lt;&lt; EOF
phi: TORSION ATOMS=5,7,9,15
psi: TORSION ATOMS=7,9,15,17

# monitor the two variables
PRINT STRIDE=100 ARG=phi,psi FILE=COLVARDEMUX.$i
EOF

plumed driver --mf_xtc ${i}_trajout.xtc --trajectory-stride=10 --plumed plumed.dat

done
</pre><p>The COLVARDEMUX.XX files will contain the value of the CVs on the demuxed trajectory. If we visualize these files we will notice that replicas sample the CVs space differently. In order for each umbrella to equilibrate the slow degrees of freedom phi, the continuous replicas must be ergodic and thus sample the same distribution in phi and psi.</p>
<p><a class="anchor" id="munster-usrem-psi-demux"></a></p><div class="image">
<img src="munster-usrem-psi-demux.png" alt="munster-usrem-psi-demux.png"/>
<div class="caption">
(phi,psi) scatter plot from the demuxed trajectories of the multiple restraints simulation in psi.</div></div>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
<!--    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>  -->
    <li class="footer">   <!--- Generated by -->
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
