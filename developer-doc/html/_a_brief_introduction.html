<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>PLUMED: A brief introduction to the plumed core</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table align="center" frame="void" width="98%" cellpadding="2%">
<tbody>
<tr style="height: 30px;">
<td valign="center"> &nbsp; <img src="pigeon.png" width="120"/></td>
<td style="padding-left: 0.2em;" width="74%"> <a href="http://www.plumed-code.org"> <img src="logo.png" width="400" /> </td>
<td style="padding-left: 0.2em;" align="right"> <a href="../../user-doc/html/index.html"> <img src="developer-logo.png" width="180" /> </a> </td>
</tr>
</tbody>
</table>
<!--
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PLUMED
   &#160;<span id="projectnumber">2.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
-->
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">A brief introduction to the plumed core </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Plumed 2, unlike its predecessor plumed 1, which was written in plain C, is written in C++.</p>
<p>C++, unlike C, fortran and many of the other languages that are commonly used in the atomistic simulation community, is an object oriented programming language. As such the way things are done in plumed may feel unfamiliar to developers in the scientific community who, if our experience is anything to go by, are more used to programming in non-object oriented languages. For this reason we have tried in what follows to explain how we have used the features of object oriented programming in plumed 2. We hope that this guide is helpful and appologize in advance to any developers who feel patronized.</p>
<h1><a class="anchor" id="intro"></a>
Object oriented programming</h1>
<p>The main objective in object oriented programming is to write code that is more resilient to bugs. There are two ways that object oriented programing allows us to acchieve these aims:</p>
<ul>
<li>In object oriented programs one generally needs fewer lines of code</li>
<li>Object oriented programming allows us to use the compiler to do many more checks of the code</li>
</ul>
<p>To be clear though object oriented programming does not allow us to do things that would be impossible with other programming languages. All programs perform some set of mathematical operations and any programming language can be used to implement these mathematical operations. The only advantage of C++ is that the advanced, object-oriented features of the language make implementing things more straighforward.</p>
<p>As you are no doubt aware, in C one can create structures to order the variables in your code. A naive way of thinking about the objects, or more correctly classes, that one uses in C++ is that these are structures that also contain functions. This is useful for making neat header files as the parameters are kept near the functions. However, at this level of thinking the C++ way of doing things:</p>
<pre class="fragment">class fclass {
bool param0;
int param1,param2;
double param3;
double f( double x );
}; 
</pre><p>is not much better than the C way of doing things:</p>
<pre class="fragment">struct fparams {
bool param0;
int param1,param2;
double param3;
}; 
double f( double x, struct fparams myparams ); 
</pre><p><b> Nevertheless for reasons that will hopefully become clear as you read this document every bias, colvar and function that is implemented in plumed 2 is inside its own separate class. </b></p>
<h1><a class="anchor" id="publicprivate"></a>
Public and private members</h1>
<p>The variables in a C struct can be accessed anywhere in the code - any function in the code can copy the information from a structure or change the values of the variables in the structure. This was a particularly fun feature of plumed 1.0, every function in the old code could change any of the variables in the code! Obviously this causes problems as new functions can accidentally change the values of some variable in a widely used structure that should never have been changed. As one can imagine this can cause drastic problems. To prevent errors like this C++ provides a set of functionalities to allow one to specify what any given function can do to the members of a class. This is not possible in C and it was the ability to use this functionality to create flexible, easily-extendable code that motivated our choice of C++ for plumed 2. The example class below shows how this is done in practise:</p>
<pre class="fragment">class myclass{
private:
  bool b;  //--This can only be accessed when you are in one of the methods in the class
public:
  int i;  //--This can be acessed by anywhere in the code
};

\section constructors Constructors

As someone who learnt to program in fortran it was this aspect of C++, more than any other, that confused me 
the most. In actually though it is rather simple and I don't really know why I was confused. In essence every 
class must contain some method for creating it. This class should set the initial values of all the variables
inside the class. Obviously the functions (or more correctly methods) that the class
contains cannot be used untill an instance of the class has been created using the constructor. 

An example of how all this works in practise is given below:

\verbatim
class myclass{
private:
  bool b;
  int i;
  double d;
public:
  myclass( bool bb, int ii, double dd ) : b(bb), i(ii), d(dd) {}
  static double g(int j);
  double f( double x );
};

// Here there are currently no instances of myclass and so I cannot run f
// I can run g however as it is a static member of the class - I run it using
double d=myclass::g(j);

// Now I create an instance of the class using the constructor
myclass thisIsTheInstance(false, 3, 6.5);
// so that I can run the method called f 
double s=thisIsTheInstance.f(4.0); 
</pre><p><b> In plumed 2 all the lines in the input file are read in inside the constructors. This ensures that the parameters inside any given method are set correctly from the outset. </b></p>
<h1><a class="anchor" id="operators"></a>
Operators</h1>
<p>Addition, subtraction, multiplication, division and so on are all functions (they are obviously not variables). We usually don't think of them as functions however because we use these operations all the time. C++ recognizes that the short cuts of +, -, *, / and so on are very useful. It thus allows one to define operators in our new classes that explain to the compiler what a given symbol means for a given class. Among other things we can define:</p>
<ul>
<li>How to perform the logical operators !=, ==, etc</li>
<li>How to perform arithmatic for a class: +, -, /, *, +=, -= etc</li>
<li>What brackets mean i.e. the meanings of (), []</li>
</ul>
<p>We do not use this extensively in plumed 2 but it does occasionally appear.</p>
<h1><a class="anchor" id="inclusion"></a>
Including the functionality of one class in a new class 1: Inclusion</h1>
<p>There are various ways that one can include the functionality of one class inside a second class. By far the simplest is to create an instance of class 1 inside class 2 as shown below:</p>
<pre class="fragment">class class1 {
private:
  double d1,d2,d3;
public:
  class1();
  void f(double x);
};

class class2 {
private:
  class1 myclass;
public:
  class2();
  // The methods of class 2 here
};
</pre><p>This is really simple one includes a class in this way in exactly the same way that one includes a double, int or whatever variable.</p>
<p><b> This kind of inclusion is used extensively in plumed 1.0 and there are a huge number of classes that you can re-use in this way to create new colvars, functions or biases. For a full list of the classes that are available see <a class="el" href="group___t_o_o_l_b_o_x.html">Tool Box</a>. </b></p>
<h1><a class="anchor" id="inheritance"></a>
Including the functionality of one class in a second class 2: Inheritance</h1>
<p>There is an alternate way of reusing the functionality from one class in a second class that is available in C++. This method is called inheritance and it offers some advantages over simply including class A inside class B as described above. To create a class called B that inherits from A one writes:</p>
<pre class="fragment">class B : public A {
// Contents of class B
};  
</pre><p>One advantage of this method over inclusion is that I can use protected members to more closely control what members of A class B is allowed to access. Hence, rather than simply having private and public members I now have:</p>
<table  align="center" frame="void" width="95%%" cellpadding="5%%">
<tr>
<td><b> public </b>  </td><td>These members can be accessed by anyone   </td></tr>
<tr>
<td><b> protected </b>  </td><td>These members can only be accessed by the methods of class A and class B   </td></tr>
<tr>
<td><b> private </b>  </td><td>These members can only by accessed by the methods of class A (not by class B)   </td></tr>
</table>
<p>In addition, I can use inheritance to treat pointers to objects of class B as if they were pointers to objects of class A. In other words, if I create an object of type B I can convert it to an object of type A using dynamic_cast as shown below:</p>
<pre class="fragment">B* mynewB=new B();   // This is a special way of calling the constructor so you get a pointer
A* BpretendingToBeA=dynamic_cast&lt;A*&gt;(mynewB); 
</pre><p>All the colvars and free energy methods of plumed use inheritence. In fact all these methods are built on a single base class called <a class="el" href="class_p_l_m_d_1_1_action.html" title="Base class for all the input Actions. ">PLMD::Action</a>. This class contains all the functionality for reading stuff from input, the stuff for controlling the dependencies Actions and a set of controls that decide which actions are performed when. All the functionality for the different methods is then built on this root. As you can see (<a class="el" href="class_p_l_m_d_1_1_action.html" title="Base class for all the input Actions. ">PLMD::Action</a>) the inheritence tree for the code is quite complicated. However, in practise if you are implementing a CV, function, bias or virtual atom the correct start point is with one of the classes listed on this page <a class="el" href="group___i_n_h_e_r_i_t.html">Base classes for CVs, functions, biases, etc.</a> all of which contain detailed descriptions of how to use them.</p>
<h1><a class="anchor" id="minheritance"></a>
Including the functionality of one class in a second class 3: Multiple inheritance</h1>
<p>Immediately above the <a class="el" href="class_p_l_m_d_1_1_action.html" title="Base class for all the input Actions. ">PLMD::Action</a> root of the inheritance tree in plumed there is a very complicated looking layer in the inheritance structure of the code. This layer looks ugly because in this layer we are using multiple inheritance - the classes in the layer above inherit from multiple classes simultaneously. This way of incorporating functionality from classes is unique to C++ and brings with it a special set of difficulties in programming. Its great advantage is though that one can create classes that incorporate bring a set of particular attributes. This will perhaps be most clear if you look at what each of the classes in the multiple inheritence layer is doing (see <a class="el" href="group___m_u_l_t_i_i_n_h_e_r_i_t.html">Classes for multiple inheritance</a>) and see how these functionalities are used in Colvars, Functions and Biases. Please be aware that, unless you are doing something really wacky, you should be able to implement whatever you need to implement without writing classes that take advantage of multiple inheritance. Furthermore, you should not need to touch the classes in this region of the code. The information here is there for completeness only. If you feel you really must change something in this part of the code please contact the developers before doing anything.</p>
<h1><a class="anchor" id="static-poly"></a>
Static Polymorphism</h1>
<p>Polymorhpism is a way of using the same code to do many different things. As an example consider a Matrix. The elements of a Matrix can be ints, doubles, floats or even some fancy new class but we would still want the operator (i,j) to return the element in row i and column j. That is to say the operator (const int i, const int j) of a matrix is indepedent of what is actually inside the matrix. Using C++ we can use so called template classes to implement thse kinds of things and can then re-use them to do an enormous variety of different operations. To see how this works in practise take a look at <a class="el" href="class_p_l_m_d_1_1_matrix.html" title="This class stores a full matrix and allows one to do some simple matrix operations. ">PLMD::Matrix</a>, which is a working version of our Matrix example. Be aware that all the routines in a template class must be inside the header file. To use a template within the code you declare it as follows:</p>
<pre class="fragment">Matrix&lt;double&gt; mat;   // This is a matrix of doubles
</pre><p><b> The most common way we use this kind of functionality in plumed 2 is when we take advantage of the features that are available in the C++ standard library. For more details on the standard library visit <a href="http://www.cplusplus.com/reference/">http://www.cplusplus.com/reference/</a> </b></p>
<h1><a class="anchor" id="dynamic-poly"></a>
Dynamic Polymorhpism</h1>
<p>When you run a calculation with plumed the code calculates a number of CVs. The bias and the forces due to the bias are then calculated and in the final step these forces are propegated back onto the atoms using the chain rule. For example <a class="el" href="class_p_l_m_d_1_1colvar_1_1_distance.html" title="Provides the keyword DISTANCE  ">PLMD::colvar::Distance</a> contains the function that calculates a distance between atoms, while <a class="el" href="class_p_l_m_d_1_1bias_1_1_meta_d.html" title="Provides the keyword METAD  ">PLMD::bias::MetaD</a> contains the function for doing metadynamics. What may thus seem remarkable to the programmer unfamiliar with C++ is that the class that calls the functions that calculate the CVs, biases and so on only uses <a class="el" href="class_p_l_m_d_1_1_action.html" title="Base class for all the input Actions. ">PLMD::Action</a>. To make that clear it looks like the code can calculate the distances between atoms without ever calling any of the routines from <a class="el" href="class_p_l_m_d_1_1colvar_1_1_distance.html" title="Provides the keyword DISTANCE  ">PLMD::colvar::Distance</a>!</p>
<p>We can program in this way because we take advantage of dynamic polymorhpism. If you look at the documenation for <a class="el" href="class_p_l_m_d_1_1_action.html" title="Base class for all the input Actions. ">PLMD::Action</a> you will see that the method <a class="el" href="class_p_l_m_d_1_1_action.html#a7ccc23f0c343834dad6f01a409dc4b39" title="Calculate an Action. ">PLMD::Action::calculate</a> is declare inside <a class="el" href="class_p_l_m_d_1_1_action.html" title="Base class for all the input Actions. ">PLMD::Action</a> as:</p>
<pre class="fragment">virtual void calculate()=0;
</pre><p>This kind of declaration promises two things to a class:</p>
<ul>
<li>That the class will only ever be used in derived classes. No <a class="el" href="class_p_l_m_d_1_1_action.html" title="Base class for all the input Actions. ">PLMD::Action</a> class is ever constructed in the code. The functionality in <a class="el" href="class_p_l_m_d_1_1_action.html" title="Base class for all the input Actions. ">PLMD::Action</a> is only ever used in the derived classes that inherit <a class="el" href="class_p_l_m_d_1_1_action.html" title="Base class for all the input Actions. ">PLMD::Action</a>. Classes like <a class="el" href="class_p_l_m_d_1_1_action.html" title="Base class for all the input Actions. ">PLMD::Action</a> are called abstract base classes.</li>
<li>That in one of the classes that inherits from <a class="el" href="class_p_l_m_d_1_1_action.html" title="Base class for all the input Actions. ">PLMD::Action</a> a method called calculate will be defined.</li>
</ul>
<p>The great advantage of declaring calculate() inside <a class="el" href="class_p_l_m_d_1_1_action.html" title="Base class for all the input Actions. ">PLMD::Action</a> in this way is that the calculate routine that we declare in the derived class is a member of <a class="el" href="class_p_l_m_d_1_1_action.html" title="Base class for all the input Actions. ">PLMD::Action</a>. We thus can thus write a class for doing all the bussiness of plumed in the manner described previously.</p>
<h1><a class="anchor" id="ForwardDeclaration"></a>
Forward declaration</h1>
<p>One problem of including classes inside other classes in C++ is that this enforces one to include one .h file into another one, thus leading to a large set of objects needing to be recompiled just because a single .h file was touched. In some cases this is not avoidable, e.g. when classes inherits from other classes. However, when only a pointer (or a reference) to another class is used, it might be better to just use a forward declaration as in this example: </p><pre class="fragment">/////////////////////////////////////////////
// This is file A.h
namespace PLMD{

class A{
  int pippo;
};

}

/////////////////////////////////////////////
// This is file B-bad.h
// it has to include A.h
#include "A.h"
namespace PLMD{

class B{
public:
// notice that here we only use a reference to class A
  int do_something(A&amp;a);
};

}

/////////////////////////////////////////////
// This is file B-good.h
namespace PLMD{

// this command just instructs the compiler that A is a class:
class A;
// no inclusion of A.h is required!

class B{
public:
// notice that here we only use a reference to class A
  int do_something(A&amp;a);
};

}</pre><p>This trick however does not work is a class is including an instance of another class. E.g., if B <em>contains</em> an instance of A one should know exactly the A declaration to build a B object. In this case, a similar effect can be obtained at the price of adding some more lines of code in constructor and destructor of B as in the following example</p>
<pre class="fragment">/////////////////////////////////////////////
// This is file B-bad.h
// it has to include A.h
#include "A.h"
namespace PLMD{

class B{
  A content;
};

}

/////////////////////////////////////////////
// This is file B-good.h
namespace PLMD{

// this command just instructs the compiler that A is a class:
class A;
// no inclusion of A.h is required!

class B{
// As "content" is a reference, it can be used exactly as if it was a normal object
// However, it is represents by the compiler as a pointer.
  A&amp; content;
public:
  B();
  ~();
};

}

/////////////////////////////////////////////
// Using B-good.h enforces to add something in B-good.cpp

#include "A.h"
#include "B-good.h"

using namespace PLMD;

B::B():
// now "content" needs to be explicitly allocated ...
  content(*new A){
}

B::~B(){
// ... and deallocated
  delete &amp;content;
}</pre><p>Notice that this trick cannot be always be applied, e.g., if the constructor to be A needs parameter, or if object "content" is to be accessed by inline methods of B for efficiency. Another example where this does not work is when inline methods are used because of template expressions.</p>
<p>This trick is extensively used in plumed so as to avoid too many indirect dependencies among .h files.</p>
<h1><a class="anchor" id="conc"></a>
Conclusion</h1>
<p>The above is meant to give you some feel as to how plumed works. If there is stuff you do not understand it is not necessarily that important. The great advantage of the code as it is currently written is that you can implement new methods without touching the core of the code. So in conclusion give it a go and have fun!</p>
<h1><a class="anchor" id="Notes"></a>
Notes</h1>
<p>More information about C++ <a href="http://www.parashift.com/c++-faq-lite/">http://www.parashift.com/c++-faq-lite/</a> </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<table align="center" frame="void" width="98%" cellpadding="2%">
<tr><td align="left" valign="center"> 
Hosted by GitHub &nbsp;
<a href="http://github.com"><img src="octocat.png" width="88" height="66"  alt="GitHub Logo" /></a>
<!--Generated by  &#160; --> <a href="http://www.doxygen.org/index.html">
</td><td width=90% align="right">
<img class="footer" src="doxygen.png" alt="doxygen" align="right"/>
</a> 1.8.7
</td> </tr> 
</table>
</small></address>
</body>
</html>
